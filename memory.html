<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Golem Neural Cortex v9.0</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=DotGothic16&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #fcf8e3; /* ç±³é»ƒè‰²èƒŒæ™¯ */
            --box-bg: #ffffff;
            --text-color: #4a4a4a;
            --accent-pink: #ff6b81; /* é‡é»è‰²ï¼šç²‰ç´… */
            --accent-blue: #48dbfb; /* é‡é»è‰²ï¼šç²‰è— */
            --border-color: #2d3436;
            --shadow-color: rgba(0,0,0,0.15);
        }

        body { 
            font-family: 'DotGothic16', "Microsoft JhengHei", sans-serif; /* è‹±æ–‡åƒç´ ï¼Œä¸­æ–‡é»‘é«” */
            background-color: var(--bg-color);
            background-image: radial-gradient(#dcdde1 2px, transparent 2px); /* é»é»èƒŒæ™¯ */
            background-size: 20px 20px;
            color: var(--text-color); 
            padding: 30px; 
            max-width: 900px;
            margin: 0 auto;
        }

        h1 { 
            font-family: 'Press Start 2P', cursive; 
            color: var(--text-color); 
            font-size: 1.4rem; 
            margin-bottom: 2rem; 
            line-height: 1.8;
            text-shadow: 2px 2px 0px #fff;
            border-bottom: 4px solid var(--border-color);
            padding-bottom: 10px;
        }
        
        h1 span.cn-note {
            font-size: 0.6em;
            color: var(--accent-pink);
            font-family: "Microsoft JhengHei", sans-serif;
            font-weight: bold;
            margin-left: 10px;
            vertical-align: middle;
        }

        /* ğŸ“¦ åƒç´ é¢¨æ ¼å®¹å™¨ */
        .nes-container {
            background: var(--box-bg);
            border: 4px solid var(--border-color);
            padding: 20px;
            margin-bottom: 25px;
            position: relative;
            box-shadow: 6px 6px 0px var(--shadow-color);
        }
        
        /* æ¨™ç±¤ Badge */
        .nes-badge {
            position: absolute;
            top: -14px;
            left: 20px;
            background: var(--border-color);
            color: #fff;
            padding: 4px 8px;
            font-size: 0.8rem;
            font-family: 'Press Start 2P', cursive;
            border: 2px solid #fff;
        }

        /* ç‹€æ…‹æ¬„å€åŸŸ */
        .status-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .status { 
            font-family: 'DotGothic16', sans-serif;
            font-size: 0.9rem;
            padding: 15px; 
            border: 4px solid var(--border-color);
            background: #fff;
            display: flex;
            align-items: center;
            transition: all 0.2s;
            box-shadow: 4px 4px 0px var(--shadow-color);
        }

        .status-ok {
            background: #dff9fb; /* æ·ºè—èƒŒæ™¯ */
            color: #22a6b3;
            border-color: #22a6b3;
        }
        
        .status-error {
            background: #ff7979;
            color: white;
        }

        /* ğŸ’“ å¿ƒè·³å‹•ç•« */
        @keyframes heartbeat {
            0% { transform: scale(1); }
            15% { transform: scale(1.05); }
            30% { transform: scale(1); }
            45% { transform: scale(1.05); }
            60% { transform: scale(1); }
            100% { transform: scale(1); }
        }

        .heartbeat {
            animation: heartbeat 2s infinite;
        }

        /* æ—¥èªŒå€å¡Š */
        .log { 
            font-family: 'DotGothic16', monospace;
            background: #2d3436; 
            color: #dfe6e9;
            padding: 15px;
            border: 4px solid var(--border-color);
            height: 350px;
            overflow-y: auto;
            line-height: 1.6;
        }
        
        /* æ²è»¸ç¾åŒ– */
        ::-webkit-scrollbar { width: 12px; }
        ::-webkit-scrollbar-track { background: #eee; border-left: 2px solid #000; }
        ::-webkit-scrollbar-thumb { background: var(--accent-pink); border: 2px solid #000; }

        .badge-ver { background: var(--accent-blue); color: #000; padding: 2px 6px; font-size: 0.6em; border: 2px solid #000; vertical-align: middle; }
    </style>
</head>
<body>
    <h1>
        ğŸ§  Golem Neural Cortex 
        <span class="badge-ver">v9.0</span>
        <br><span class="cn-note">Golemæ™ºèƒ½é«”è¨˜æ†¶æ ¸å¿ƒ</span>
    </h1>

    <div class="nes-container">
        <span class="nes-badge" style="background:var(--accent-pink);">INFO ç³»çµ±è³‡è¨Š</span>
        <div style="color: #636e72;">
            <strong>Module:</strong> Vector Memory & Timeline Engine (Chronos)<br>
            <span style="font-size: 0.9em; color: #b2bec3;">åŸºæ–¼ç€è¦½å™¨çš„å‘é‡è¨˜æ†¶èˆ‡æ™‚é–“è»¸å¼•æ“</span>
        </div>
    </div>

    <div class="status-grid">
        <div id="model-status" class="status">
            <span>âš¡ Initializing Transformers...</span>
        </div>
        <div id="db-status" class="status">
            <span>ğŸ’¾ Connecting to IndexedDB...</span>
        </div>
    </div>

    <div class="nes-container" style="padding:0; border:none; background:transparent; box-shadow:none;">
        <div class="nes-container" style="background:#2d3436; padding:0; border-color:black;">
            <span class="nes-badge" style="background:var(--accent-blue); border-color:white;">SYSTEM LOG ç³»çµ±æ—¥èªŒ</span>
            <div id="logs" class="log"></div>
        </div>
    </div>

    <script type="module">
        import { pipeline, env } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.16.0';
        env.allowLocalModels = false;
        env.useBrowserCache = true;

        let extractor = null;
        let db = null;
        const DB_NAME = 'GolemMemoryDB';
        const DB_VERSION = 2; 
        const STORE_NAME = 'memories';
        const SCHEDULE_STORE = 'schedule';
        const MODEL_NAME = 'Xenova/all-MiniLM-L6-v2';

        const log = (msg) => {
            console.log(`[Cortex v9.0] ${msg}`);
            const logDiv = document.getElementById('logs');
            const time = new Date().toLocaleTimeString();
            // ä½¿ç”¨é¡è‰²å€åˆ†æ™‚é–“èˆ‡å…§å®¹
            logDiv.innerHTML = `<div style="border-bottom:1px dashed #555; padding-bottom:4px; margin-bottom:4px;">
                <span style="color:#feca57">[${time}]</span> ${msg}
            </div>` + logDiv.innerHTML;
        };

        async function initModel() {
            try {
                log(`Loading Model: ${MODEL_NAME}...`);
                extractor = await pipeline('feature-extraction', MODEL_NAME);
                
                const el = document.getElementById('model-status');
                el.innerHTML = "âœ… Model Active (all-MiniLM-L6-v2)<br><small>æ¨¡å‹å·²è¼‰å…¥</small>";
                el.className = "status status-ok heartbeat"; // å•Ÿç”¨å¿ƒè·³å‹•ç•«
                
                log("Neural Engine Ready.");
            } catch (e) {
                const el = document.getElementById('model-status');
                el.innerText = "âŒ Model Failed: " + e.message;
                el.className = "status status-error";
                log("Model Error: " + e.message);
            }
        }

        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
                    }
                    if (!db.objectStoreNames.contains(SCHEDULE_STORE)) {
                        log("âš™ï¸ Upgrading DB: Creating Schedule Store...");
                        const store = db.createObjectStore(SCHEDULE_STORE, { keyPath: 'id', autoIncrement: true });
                        store.createIndex('time', 'time', { unique: false });
                    }
                };
                request.onsuccess = (e) => {
                    db = e.target.result;
                    
                    const el = document.getElementById('db-status');
                    el.innerHTML = "âœ… Memory Bank Connected<br><small>è¨˜æ†¶åº«å·²é€£ç·š</small>";
                    el.className = "status status-ok heartbeat"; // å•Ÿç”¨å¿ƒè·³å‹•ç•«

                    log("Storage Ready (v" + DB_VERSION + ").");
                    resolve();
                };
                request.onerror = (e) => {
                    document.getElementById('db-status').innerText = "âŒ DB Error";
                    reject(e);
                };
            });
        }

        function cosineSimilarity(vecA, vecB) {
            let dotProduct = 0, normA = 0, normB = 0;
            for (let i = 0; i < vecA.length; i++) {
                dotProduct += vecA[i] * vecB[i];
                normA += vecA[i] * vecA[i];
                normB += vecB[i] * vecB[i];
            }
            return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
        }

        window.addMemory = async (text, metadata = {}) => {
            if (!extractor || !db) return { success: false, error: "System not ready" };
            try {
                const output = await extractor(text, { pooling: 'mean', normalize: true });
                const embedding = Array.from(output.data);
                const tx = db.transaction(STORE_NAME, 'readwrite');
                const store = tx.objectStore(STORE_NAME);
                store.add({ text: text, embedding: embedding, metadata: metadata, timestamp: Date.now() });
                log(`Memorized: "${text.substring(0, 30)}..."`);
                return { success: true };
            } catch (e) { return { success: false, error: e.message }; }
        };

        window.queryMemory = async (text, topK = 3) => {
            if (!extractor || !db) return [];
            try {
                const output = await extractor(text, { pooling: 'mean', normalize: true });
                const queryVec = Array.from(output.data);
                return new Promise((resolve) => {
                    const tx = db.transaction(STORE_NAME, 'readonly');
                    const store = tx.objectStore(STORE_NAME);
                    const request = store.getAll();
                    request.onsuccess = () => {
                        const allMemories = request.result;
                        const scored = allMemories.map(mem => ({
                            text: mem.text,
                            metadata: mem.metadata,
                            score: cosineSimilarity(queryVec, mem.embedding)
                        }));
                        scored.sort((a, b) => b.score - a.score);
                        const results = scored.filter(m => m.score > 0.25).slice(0, topK);
                        if (results.length > 0) log(`Recall hit: "${results[0].text.substring(0, 20)}..." (${(results[0].score*100).toFixed(0)}%)`);
                        else log(`Recall miss for: "${text.substring(0,15)}..."`);
                        resolve(results);
                    };
                });
            } catch (e) { log("Query Error: " + e.message); return []; }
        };

        window.addSchedule = async (task, timeISO) => {
            if (!db) return { success: false };
            return new Promise((resolve) => {
                const tx = db.transaction(SCHEDULE_STORE, 'readwrite');
                const store = tx.objectStore(SCHEDULE_STORE);
                store.add({ task: task, time: timeISO, status: 'pending', createdAt: Date.now() });
                tx.oncomplete = () => {
                    log(`ğŸ“… Scheduled: "${task}" at ${timeISO}`);
                    resolve({ success: true });
                };
                tx.onerror = () => resolve({ success: false, error: tx.error });
            });
        };

        window.checkSchedule = async () => {
            if (!db) return [];
            const nowISO = new Date().toISOString();
            return new Promise((resolve) => {
                const tx = db.transaction(SCHEDULE_STORE, 'readwrite');
                const store = tx.objectStore(SCHEDULE_STORE);
                const index = store.index('time');
                const range = IDBKeyRange.upperBound(nowISO);
                const request = index.openCursor(range);
                const dueTasks = [];
                request.onsuccess = (e) => {
                    const cursor = e.target.result;
                    if (cursor) {
                        const record = cursor.value;
                        if (record.status === 'pending') {
                            dueTasks.push(record);
                            cursor.delete(); 
                        }
                        cursor.continue();
                    } else {
                        if (dueTasks.length > 0) log(`â° Triggered ${dueTasks.length} tasks`);
                        resolve(dueTasks);
                    }
                };
                request.onerror = () => resolve([]);
            });
        };

        (async () => {
            await initDB();
            await initModel();
        })();
    </script>
</body>
</html>
