<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Golem Neural Cortex v8.5</title>
    <style>
        body { font-family: 'Segoe UI', monospace; background: #0d1117; color: #c9d1d9; padding: 20px; }
        .status { padding: 12px; border: 1px solid #30363d; margin-bottom: 10px; border-radius: 6px; background: #161b22; }
        .log { color: #8b949e; font-size: 0.9em; margin-top: 20px; font-family: monospace; border-top: 1px solid #30363d; padding-top: 10px;}
        h1 { color: #58a6ff; font-size: 1.5rem; margin-bottom: 0.5rem; }
        .badge { display: inline-block; padding: 2px 6px; border-radius: 4px; font-size: 0.8em; margin-left: 10px; }
        .badge-browser { background: #1f6feb; color: white; }
    </style>
</head>
<body>
    <h1>ğŸ§  Golem Neural Cortex <span class="badge badge-browser">v8.5</span></h1>
    <div style="color: #8b949e; margin-bottom: 20px;">Browser-based Vector Memory Engine (Neuro-Link Ready)</div>

    <div id="model-status" class="status">âš¡ Initializing Transformers.js...</div>
    <div id="db-status" class="status">ğŸ’¾ Connecting to IndexedDB...</div>
    <div id="logs" class="log"></div>

    <script type="module">
        // ä½¿ç”¨ CDN è¼‰å…¥ Transformers.js (ç‰ˆæœ¬å›ºå®šä»¥ç¢ºä¿ç©©å®šæ€§)
        import { pipeline, env } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.16.0';

        // è¨­å®šï¼šä¸ä½¿ç”¨æœ¬åœ°å¿«å–æ¨¡å‹æª”æ¡ˆ (ç›´æ¥å¾ CDN æ‹‰å–)
        env.allowLocalModels = false;
        env.useBrowserCache = true;

        let extractor = null;
        let db = null;
        const DB_NAME = 'GolemMemoryDB';
        const STORE_NAME = 'memories';
        const MODEL_NAME = 'Xenova/all-MiniLM-L6-v2'; // è¼•é‡ç´š Embedding æ¨¡å‹

        // UI Helper
        const log = (msg) => {
            console.log(`[Cortex v8.5] ${msg}`);
            const logDiv = document.getElementById('logs');
            logDiv.innerHTML = `<div><span style="color:#58a6ff">${new Date().toLocaleTimeString()}</span> - ${msg}</div>` + logDiv.innerHTML;
        };

        // 1. åˆå§‹åŒ– AI æ¨¡å‹
        async function initModel() {
            try {
                log(`Loading Model: ${MODEL_NAME}...`);
                // feature-extraction å°ˆé–€ç”¨æ–¼ç”¢ç”Ÿå‘é‡
                extractor = await pipeline('feature-extraction', MODEL_NAME);
                document.getElementById('model-status').innerText = "âœ… Model Active (all-MiniLM-L6-v2)";
                document.getElementById('model-status').style.borderColor = "#238636";
                document.getElementById('model-status').style.color = "#3fb950";
                log("Neural Engine Ready.");
            } catch (e) {
                document.getElementById('model-status').innerText = "âŒ Model Failed: " + e.message;
                document.getElementById('model-status').style.borderColor = "#da3633";
                log("Model Error: " + e.message);
            }
        }

        // 2. åˆå§‹åŒ– IndexedDB
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, 1);

                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
                    }
                };

                request.onsuccess = (e) => {
                    db = e.target.result;
                    document.getElementById('db-status').innerText = "âœ… Memory Bank Connected";
                    document.getElementById('db-status').style.borderColor = "#238636";
                    document.getElementById('db-status').style.color = "#3fb950";
                    log("Storage Ready.");
                    resolve();
                };

                request.onerror = (e) => {
                    document.getElementById('db-status').innerText = "âŒ DB Error";
                    reject(e);
                };
            });
        }

        // æ•¸å­¸å·¥å…·ï¼šé¤˜å¼¦ç›¸ä¼¼åº¦
        function cosineSimilarity(vecA, vecB) {
            let dotProduct = 0;
            let normA = 0;
            let normB = 0;
            for (let i = 0; i < vecA.length; i++) {
                dotProduct += vecA[i] * vecB[i];
                normA += vecA[i] * vecA[i];
                normB += vecB[i] * vecB[i];
            }
            return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
        }

        // ==========================================
        // ğŸš€ é–‹æ”¾çµ¦ Node.js (Puppeteer) å‘¼å«çš„ API
        // ==========================================

        /**
         * å¯«å…¥è¨˜æ†¶
         */
        window.addMemory = async (text, metadata = {}) => {
            if (!extractor || !db) return { success: false, error: "System not ready" };

            try {
                // 1. è½‰å‘é‡
                const output = await extractor(text, { pooling: 'mean', normalize: true });
                const embedding = Array.from(output.data);

                // 2. å­˜å…¥ DB
                const tx = db.transaction(STORE_NAME, 'readwrite');
                const store = tx.objectStore(STORE_NAME);

                const memoryItem = {
                    text: text,
                    embedding: embedding,
                    metadata: metadata,
                    timestamp: Date.now()
                };

                store.add(memoryItem);
                log(`Memorized: "${text.substring(0, 30)}..."`);
                return { success: true };
            } catch (e) {
                return { success: false, error: e.message };
            }
        };

        /**
         * è®€å–/æœå°‹è¨˜æ†¶
         */
        window.queryMemory = async (text, topK = 3) => {
            if (!extractor || !db) return [];

            try {
                // 1. Query è½‰å‘é‡
                const output = await extractor(text, { pooling: 'mean', normalize: true });
                const queryVec = Array.from(output.data);

                // 2. å…¨é‡æƒæ (ç€è¦½å™¨ç«¯ < 10è¬ç­†è³‡æ–™æ¯«ç§’ç´šå®Œæˆ)
                return new Promise((resolve) => {
                    const tx = db.transaction(STORE_NAME, 'readonly');
                    const store = tx.objectStore(STORE_NAME);
                    const request = store.getAll();

                    request.onsuccess = () => {
                        const allMemories = request.result;

                        // 3. è¨ˆç®—ç›¸ä¼¼åº¦
                        const scored = allMemories.map(mem => ({
                            text: mem.text,
                            metadata: mem.metadata,
                            score: cosineSimilarity(queryVec, mem.embedding)
                        }));

                        // 4. æ’åºèˆ‡éæ¿¾ (Threshold: 0.25)
                        scored.sort((a, b) => b.score - a.score);

                        const results = scored
                            .filter(m => m.score > 0.25)
                            .slice(0, topK);

                        if (results.length > 0) {
                            log(`Recall hit: "${results[0].text.substring(0, 20)}..." (${(results[0].score*100).toFixed(0)}%)`);
                        } else {
                            log(`Recall miss for: "${text.substring(0,15)}..."`);
                        }

                        resolve(results);
                    };
                });
            } catch (e) {
                log("Query Error: " + e.message);
                return [];
            }
        };

        // å•Ÿå‹•ç¨‹åº
        (async () => {
            await initDB();
            await initModel();
        })();
    </script>
</body>
</html>
